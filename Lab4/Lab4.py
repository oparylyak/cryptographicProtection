"""
1. Реалізувати у вигляді функції gcdex(a,b) ітераційний розширений алгоритм Евкліда пошуку трійки (d,x,y), де ax+by = d. Протестити на прикладі  a= 612 і b=342.

2. Реалізувати у вигляді функції inverse_element(a,n) пошук розв'язку рівняння ax=1 (mod n), тобто знаходження мультиплікативноо оберненого елемента a^(-1) по модулю n, використовуючи gcdex(a,b).  Протестити на прикладі  a= 5 і  n=18.

3. Реалізувати у вигляді функції phi(m) обчислення значення функції Ейлера для заданого m (https://en.wikipedia.org/wiki/Euler%27s_totient_function)

4. Реалізувати у вигляді функції inverse_element_2(a,p) знаходження мультиплікативного оберненого елемента a^(-1) по модулю числа n, використовуючи інший спосіб (теорему Ейлера або малу теорему Ферма у випадку простого числа n=p). Протестити на прикладі  a= 5 і  n=18.

Протестувати роботу функцій та заскрінити.
"""

def gcdex(a, b):
    if a == 0:
        return b, 0, 1

    gcd, x1, y1 = gcdex(b % a, a)

    x = y1 - (b // a) * x1
    y = x1

    return gcd, x, y


a, b = 35, 15
g, x, y = gcdex(a, b)
print("gcd(", a, ",", b, ") = ", g)